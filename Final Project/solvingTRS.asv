%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Solves Trust Region subproblem various through various optimization
% techniques.
%
% Author
%   Trevor Squires
%
% Details
%   Solves TRS via 4 different approaches:
%   - SDP reformulation
%   - Convex reformulation/relaxation
%   - Stochastic gradient descent
%   - Double-Start FOCM (Beck)
%
% Notes
%   - Output is not correct
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [conRef,beck,sgd] = solvingTRS(dim,conParam,beckParam,sgdParam)
%% Problem setting
%rng(100)
% Controlled Generation
% eigVal = randi(10,dim,1);
% negEigValInd = randi(dim,floor(dim/2),1);
% eigVal(negEigValInd) = -eigVal(negEigValInd);
% eigMin = min(eigVal);
% 
% [eigVec,~] = qr(randn(dim));
% A = eigVec'*diag(eigVal)*eigVec;

% Matrix/Vector Generation
A = rand(dim);
A = A+A';
b = randn(dim,1);

% Instance parameters
eigMin = min(eig(A));
L = norm(A,2);

% Function Setup
f = @(x) 0.5*x'*A*x + b'*x;
gradf = @(x) A*x+b;
g = @(x) f(x) - 0.5*eigMin*norm(x,2)^2;
gradg = @(x) gradf(x) + eigMin*x;


%% TRS via convex reformulation
maxIt = defaultField(conParam,'maxIt',100);
x = zeros(dim,maxIt);
objVal = zeros(maxIt,1);

x(:,1) = randn(dim,1);
x(:,1) = x(:,1)/norm(x(:,1),2);

for i = 2:maxIt
    x(:,i) = x(:,i-1) - 1/(L+eigMin)*gradg(x(:,i-1));
    tmp = norm(x(:,i));
    if tmp > 1
        x(:,i) = x(:,i)/tmp;
    end
    objVal(i) = g(x(:,i));
end
solu = x(:,end);

% Minimizer is the same as the original problem, but objective value is not
optVal = f(solu);

% Store useful variables in a structure
conRef.obj = g;
conRef.gradObj = gradg;
conRef.objVal = objVal;
conRef.x = x;
conRef.solu = solu;
conRef.optVal = optVal;

%% TRS via Beck paper
maxIt = defaultField(beckParam,'maxIt',100);
x = zeros(dim,maxIt);
y = zeros(dim,maxIt);
objValX = zeros(maxIt,1);
objValY = zeros(maxIt,1);

% First pass
y(:,1) = randn(dim,1);
y(:,1) = y(:,1)/norm(y(:,1),2);
objValY(1) = 
for i = 2:maxIt
    y(:,i) = y(:,i-1) - 1/L*gradf(y(:,i-1));
    tmp = norm(y(:,i));
    if tmp > 1
        y(:,i) = y(:,i)/tmp;
    end
    objValY(i) = f(y(:,i));
end
soluY = y(:,end);

% Second pass
x(:,1) = zeros(dim,1);
for i = 2:maxIt
    x(:,i) = x(:,i-1) - 1/L*gradf(x(:,i-1));
    tmp = norm(x(:,i));
    if tmp > 1
        x(:,i) = x(:,i)/tmp;
    end
    objValX(i) = f(x(:,i));
end
soluX = x(:,end);

% Store useful objects in structure
beck.obj = f;
beck.gradObj = gradf;
beck.objValX = objValX;
beck.objValY = objValY;

% Pick best solution 
if f(soluX)<f(soluY)
    beck.x = x;
    beck.solu = soluX;
    beck.optVal = f(soluX);
else
    beck.x = y;
    beck.solu = soluY;
    beck.optVal = f(soluY);
end

%% TRS via Stochastic Gradient Descent
epochs = defaultField(sgdParam,'epochs',100);
miniBatchProp = defaultField(sgdParam,'miniBatchProp',0.2);
miniBatchSize = ceil(dim*miniBatchProp);
maxIt = ceil(epochs/miniBatchProp);

x = zeros(dim,maxIt);
objVal = zeros(maxIt,1);

x(:,1) = randn(dim,1);
x(:,1) = x(:,1)/norm(x(:,1),2);

for i = 2:maxIt
    %Compute partial gradient
    miniBatchInd = randi(dim,miniBatchSize,1);
    partialGrad = b;
    for j = 1:miniBatchSize
        partialGrad = partialGrad + A(:,miniBatchInd(j))*x(miniBatchInd(j),i-1);
    end
    %Update using partial gradient
    x(:,i) = x(:,i-1) - 1/(L+eigMin)*partialGrad;
    tmp = norm(x(:,i));
    if tmp > 1
        x(:,i) = x(:,i)/tmp;
    end
    objVal(i) = f(x(:,i));
end
solu = x(:,end);

% Store useful objects in structures
sgd.obj = f;
sgd.gradObj = gradf;
sgd.objVal = objVal;
sgd.x = x;
sgd.solu = solu;
sgd.optVal = optVal;